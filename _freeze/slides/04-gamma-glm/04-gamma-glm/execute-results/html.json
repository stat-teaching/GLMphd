{
  "hash": "03a671b0ec4567aa9ace43bc11ba5762",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Gamma GLM\nbibliography: \"https://raw.githubusercontent.com/filippogambarota/bib-database/main/references.bib\"\ncsl: \"https://raw.githubusercontent.com/citation-style-language/styles/master/apa.csl\"\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n\n# Gamma Distribution {.section}\n\n## Gamma distribution\n\nThe Gamma distribution has several [:parametrizations](https://en.wikipedia.org/wiki/Gamma_distribution). One of the most common is the **shape-scale** parametrization:\n\n$$\nf(x;k,\\theta )={\\frac {x^{k-1}e^{-x/\\theta }}{\\theta ^{k}\\Gamma (k)}}\n$$\nWhere $\\theta$ is the **scale** parameter and $k$ is the **shape** parameter.\n\n## Gamma distribution\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggamma(mean = c(10, 20, 30), sd = c(10, 10, 10), show = \"ss\")\n```\n\n::: {.cell-output-display}\n![](04-gamma-glm_files/figure-revealjs/unnamed-chunk-2-1.svg){fig-align='center' width=576}\n:::\n:::\n\n\n\n## Gamma $\\mu$ and $\\sigma^2$\n\nThe mean and variance are defined as:\n\n- $\\mu = k \\theta$ and $\\sigma^2 = k \\theta^2$ with the **shape-scale** parametrization\n- $\\mu = \\frac{\\alpha}{\\beta}$ and $\\frac{\\alpha}{\\beta^2}$ with the **shape-rate** parametrization\n\n. . .\n\nAnother important quantity is the **coefficient of variation** defined as $\\frac{\\sigma}{\\mu}$ or $\\frac{1}{\\sqrt{k}}$ (or $\\frac{1}{\\sqrt{\\alpha}}$).\n\n## Gamma distribution\n\nAgain, we can see the mean-variance relationship:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggamma(shape = c(5, 5), scale = c(10, 20), show = \"ss\")\n```\n\n::: {.cell-output-display}\n![](04-gamma-glm_files/figure-revealjs/unnamed-chunk-3-1.svg){fig-align='center' width=576}\n:::\n:::\n\n\n\n\n## Gamma parametrization\n\nTo convert between different parametrizations, you can use the `gamma_params()` function:\n\n\n\n::: {.cell layout-align=\"center\"}\n```r\ngamma_params <- function(shape = NULL, scale = 1/rate, rate = 1,\n                         mean = NULL, sd = NULL,\n                         eqs = FALSE){\n  if(eqs){\n    cat(rep(\"=\", 25), \"\\n\")\n    cat(eqs()$gamma, \"\\n\")\n    cat(rep(\"=\", 25), \"\\n\")\n  }else{\n      if(is.null(shape)){\n      var <- sd^2\n      shape <- mean^2 / var\n      scale <- mean / shape\n      rate <- 1/scale\n    } else if(is.null(mean) & is.null(sd)){\n      if(is.null(rate)){\n        scale <- 1/rate\n      } else{\n        rate <- 1/scale\n      }\n      mean <- shape * scale\n      var <- shape * scale^2\n      sd <- sqrt(var)\n    }else{\n      stop(\"when shape and scale are provided, mean and sd need to be NULL (and viceversa)\")\n    }\n    out <- list(shape = shape, scale = scale, rate = rate, mean = mean, var = var, sd = sd)\n    # coefficient of variation\n    out$cv <- 1/sqrt(shape)\n    return(out)\n  }\n}\n```\n:::\n\n\n\n## Gamma parametrization\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"false\"}\ngm <- gamma_params(mean = 30, sd = 10)\nunlist(gm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>       shape       scale        rate        mean         var          sd \n#>   9.0000000   3.3333333   0.3000000  30.0000000 100.0000000  10.0000000 \n#>          cv \n#>   0.3333333\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\ny <- rgamma(1000, shape = gm$shape, scale = gm$scale)\n```\n:::\n\n\n\n## Gamma parametrization\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](04-gamma-glm_files/figure-revealjs/unnamed-chunk-6-1.svg){fig-align='center' width=576}\n:::\n:::\n\n\n\n# Understanding parameters {.section}\n\n## $\\mu$ and $\\sigma$ parametrization\n\n- Using the `gamma_params()` function we can think in terms of $\\mu$ and $\\sigma$ and generate the right parameters (e.g., *shape* and *rate*).\n- Let's simulate observations from a Gamma distribution with $\\mu = 500$ and $\\sigma = 200$\n\n. . .\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](04-gamma-glm_files/figure-revealjs/unnamed-chunk-7-1.svg){fig-align='center' width=576}\n:::\n:::\n\n\n\n## $\\mu$ and $\\sigma$ parametrization\n\nThen we can fit an intercept-only model with the `Gamma` family and a `log` link function. You have to specify the link because the default is `inverse`.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfam <- Gamma(link = \"log\")\ndat <- data.frame(y)\nfit0 <- glm(y ~ 1, family = fam, data = dat)\nsummary(fit0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> \n#> Call:\n#> glm(formula = y ~ 1, family = fam, data = dat)\n#> \n#> Coefficients:\n#>             Estimate Std. Error t value Pr(>|t|)    \n#> (Intercept) 6.205013   0.003959    1567   <2e-16 ***\n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#> \n#> (Dispersion parameter for Gamma family taken to be 0.1567542)\n#> \n#>     Null deviance: 1625.2  on 9999  degrees of freedom\n#> Residual deviance: 1625.2  on 9999  degrees of freedom\n#> AIC: 132959\n#> \n#> Number of Fisher Scoring iterations: 4\n```\n\n\n:::\n:::\n\n\n\n## $\\mu$ and $\\sigma$ parametrization\n\n$\\beta_0$ is the $\\mu$ of the Gamma distribution. We need to apply the inverse (`exp`) to get the original scale:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nc(mean = mean(dat$y), mean_true = gm$mean, b0 = exp(coef(fit0)[1]))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>           mean      mean_true b0.(Intercept) \n#>       495.2254       500.0000       495.2254\n```\n\n\n:::\n:::\n\n\n\nas always you can use the `fam()` object if you are not sure about the link functions as `fam$linkinv(coef(fit0)[1])`\n\n## $\\mu$ and $\\sigma$ parametrization\n\nNow let's simulate the difference between two groups. Again fixing the $\\mu_0 = 500$, $\\mu_1 = 600$ and a common $\\sigma = 200$. Let's plot the empirical densities:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggamma(mean = c(500, 600), sd = c(200, 200))\n```\n\n::: {.cell-output-display}\n![](04-gamma-glm_files/figure-revealjs/unnamed-chunk-10-1.svg){fig-align='center' width=576}\n:::\n:::\n\n\n\n## $\\mu$ and $\\sigma$ parametrization\n\nUsing the `group` variable as dummy-coded, $\\beta_0 = \\mu_0$ and $\\beta_1 = \\mu_1 - \\mu_0$. Note that we are in the log scale.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"false\"}\nns <- 1e4\nm0 <- 500\nm1 <- 600\ns <- 200\n# parameters, log link\nb0 <- log(m0)\nb1 <- log(m1) - log(m0) # equivalent to log(m1 / m0)\nx <- rep(c(0, 1), each = ns/2)\nlp <- b0 + b1 * x # linear predictor\nmu <- exp(lp) # inverse exp link\ngm <- gamma_params(mean = mu, sd = s)\ny <- rgamma(ns, shape = gm$shape, scale = gm$scale)\ndat <- data.frame(y, x)\n```\n:::\n\n\n\n## $\\mu$ and $\\sigma$ parametrization\n\nLet's see the simulated data:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npar(mfrow = c(1,2))\nhist(dat$y, col = \"dodgerblue\", breaks = 100)\nboxplot(y ~ x, data = dat)\n```\n\n::: {.cell-output-display}\n![](04-gamma-glm_files/figure-revealjs/unnamed-chunk-12-1.svg){fig-align='center' width=576}\n:::\n:::\n\n\n\n## $\\mu$ and $\\sigma$ parametrization\n\nNow we can fit the model and extract the parameters:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfit <- glm(y ~ x, data = dat, family = fam)\nsummary(fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> \n#> Call:\n#> glm(formula = y ~ x, family = fam, data = dat)\n#> \n#> Coefficients:\n#>             Estimate Std. Error t value Pr(>|t|)    \n#> (Intercept) 6.214269   0.005242 1185.58   <2e-16 ***\n#> x           0.181938   0.007413   24.54   <2e-16 ***\n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#> \n#> (Dispersion parameter for Gamma family taken to be 0.1373681)\n#> \n#>     Null deviance: 1486.5  on 9999  degrees of freedom\n#> Residual deviance: 1403.8  on 9998  degrees of freedom\n#> AIC: 133686\n#> \n#> Number of Fisher Scoring iterations: 4\n```\n\n\n:::\n:::\n\n\n\n## $\\mu$ and $\\sigma$ parametrization\n\n$\\beta_0$ is the mean of the first group and $\\beta_1$ is the $\\log(\\mu_1/\\mu_0)$ or the difference $\\log(\\mu_1) - log(\\mu_0)$ \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"false\"}\nmm <- tapply(dat$y, dat$x, mean)\ncoefs <- coef(fit)\n# manually\nc(mm[\"0\"], mm[\"1\"], diff = log(mm[\"1\"]) - log(mm[\"0\"]))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>           0           1      diff.1 \n#> 499.8307000 599.5669342   0.1819382\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n# model\nc(exp(coefs[1]), exp(coefs[1] + coefs[2]), coefs[2])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> (Intercept) (Intercept)           x \n#> 499.8307000 599.5669342   0.1819382\n```\n\n\n:::\n:::\n\n\n\n## $\\mu$ and $\\sigma$ parametrization\n\nThe other estimated parameter is the **dispersion** that is defined as the inverse of the **shape**. We have not a single shape but the average is roughly similar to the true value.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"false\"}\nfits <- summary(fit)\nfits$dispersion\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.1373681\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n1/mean(unique(gm$shape))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.1311475\n```\n\n\n:::\n:::\n\n\n\n## $\\mu$ and `shape` parametrization\n\nThis is common in `brms` and other packages^[See an example https://rpubs.com/jwesner/gamma_glm]. The $\\mu$ is the same as before and the `shape` ($\\alpha$) **determine the skewness of the distribution**. For the Gamma, the skewness is calculated as $\\frac{2}{\\sqrt{\\alpha}}$.\n\n\nTo generate data, we calculate the **scale** ($\\theta$) as $\\frac{\\mu}{\\alpha}$ (remember that $\\mu = \\alpha\\theta$)\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmu <- 50\nshape <- 10\ny <- rgamma(1e4, shape = shape, scale = mu/shape)\nhist(y, col = \"dodgerblue\", breaks = 100)\n```\n\n::: {.cell-output-display}\n![](04-gamma-glm_files/figure-revealjs/unnamed-chunk-16-1.svg){fig-align='center' width=576}\n:::\n:::\n\n\n\n## $\\mu$ and `shape` parametrization\n\nthe expected skewness is `2/sqrt(shape)` 0.632 and is similar to the value computed on the simulated data\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"false\"}\n2/sqrt(shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.6324555\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\npsych::skew(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.6141622\n```\n\n\n:::\n:::\n\n\n\nas $\\alpha$ increase, the Gamma distribution is less skewed and approaches a Gaussian distribution. When $\\mu = \\alpha$ the distribution already start to be pretty Gaussian\n\n## Skewness - $\\alpha$ relationship\n\nWe can plot the function that determine the skewness of the Gamma fixing $\\mu$ and varying $\\alpha$:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncurve(2/sqrt(x), 0, 50, ylab = \"Skewness\", xlab = latex(\"\\\\alpha (shape)\"))\n```\n\n::: {.cell-output-display}\n![](04-gamma-glm_files/figure-revealjs/unnamed-chunk-18-1.svg){fig-align='center' width=576}\n:::\n:::\n\n\n\n## Skewness - $\\alpha$ relationship\n\nCompared to the $\\mu$-$\\sigma$ method, here we fix the skewness and $\\mu$, thus the $\\hat \\sigma$ will differ when $\\mu$ change but the skewness is the same. The opposite is also true.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmu <- c(50, 80)\n\n# mu-shape parametrization\ny1 <- rgamma(1e6, shape = 10, scale = mu[1]/10)\ny2 <- rgamma(1e6, shape = 10, scale = mu[2]/10)\n\n# mu-sigma parametrization\ngm <- gamma_params(mean = mu, sd = c(20, 20))\nx1 <- rgamma(1e6, shape = gm$shape[1], scale = gm$scale[1])\nx2 <- rgamma(1e6, shape = gm$shape[2], scale = gm$scale[2])\n\npar(mfrow = c(1,2))\n\nplot(density(y1), lwd = 2, main = latex(\"\\\\mu and \\\\alpha parametrization\"), xlab = \"x\", xlim = c(0, 250))\nlines(density(y2), col = \"firebrick\", lwd = 2)\nlegend(\"topright\", \n       legend = c(latex(\"\\\\mu = %s, \\\\alpha = %s, \\\\hat{\\\\sigma} = %.0f, sk = %.2f\", mu[1], 10, sd(y1), psych::skew(y1)),\n                  latex(\"\\\\mu = %s, \\\\alpha = %s, \\\\hat{\\\\sigma} = %.0f, sk = %.2f\", mu[2], 10, sd(y2), psych::skew(y1))),\n       fill = c(\"black\", \"firebrick\"))\n\nhatshape <- c(gamma_shape(x1, \"invskew\"), gamma_shape(x2, \"invskew\"))\n\nplot(density(x1), lwd = 2, main = latex(\"\\\\mu and \\\\sigma parametrization\"), xlab = \"x\", xlim = c(0, 250))\nlines(density(x2), col = \"firebrick\", lwd = 2)\nlegend(\"topright\", \n       legend = c(latex(\"\\\\mu = %s, \\\\sigma = %s, \\\\hat{\\\\alpha} = %.0f, sk = %.2f\", mu[1], 20, hatshape[1], psych::skew(x1)),\n                  latex(\"\\\\mu = %s, \\\\sigma = %s, \\\\hat{\\\\alpha} = %.0f, sk = %.2f\", mu[2], 20, hatshape[2], psych::skew(x2))),\n       fill = c(\"black\", \"firebrick\"))\n```\n\n::: {.cell-output-display}\n![](04-gamma-glm_files/figure-revealjs/unnamed-chunk-19-1.svg){fig-align='center' width=960}\n:::\n:::\n\n\n\n## Coefficient of variation\n\nThe *coefficient of variation* $\\frac{\\sigma}{\\mu} = \\frac{1}{\\sqrt{\\alpha}}$ is constant under the $\\mu$-$\\alpha$ parametrization while can be different under the $\\mu$-$\\sigma$ one when $\\alpha$ or $\\sigma$ is fixed across conditions.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# mu-shape\nc(cv(y1), cv(y2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.3164771 0.3162804\n```\n\n\n:::\n\n```{.r .cell-code}\n# mu-sigma\nc(cv(x1), cv(x2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.4002609 0.2499978\n```\n\n\n:::\n:::\n\n\n\nThe $\\alpha$ parameter allow to control the coefficient of variation.\n\n## $\\mu$ and $\\sigma$ relationship\n\nSee [https://civil.colorado.edu/~balajir/CVEN6833/lectures/GammaGLM-01.pdf](https://civil.colorado.edu/~balajir/CVEN6833/lectures/GammaGLM-01.pdf). The $\\sigma = \\frac{\\mu}{\\sqrt{\\alpha}}$.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmu <- 50\ncurve(mu / sqrt(x), 0, 100, xlab = latex(\"\\\\alpha\"), ylab = latex(\"\\\\sigma = \\\\mu/\\\\sqrt{\\\\alpha}\"))\n```\n\n::: {.cell-output-display}\n![](04-gamma-glm_files/figure-revealjs/unnamed-chunk-21-1.svg){fig-align='center' width=576}\n:::\n:::\n\n\n\n## $\\mu$ and $\\sigma$ relationship\n\nAs noted by @Agresti2015-cz, fixing $\\alpha$ and varying $\\mu$, the coefficient of variation will be constant and the standard deviation $\\sigma$ increase proportionally with $\\mu$. Given that $\\sigma = \\frac{\\mu}{\\sqrt{\\alpha}}$:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"false\"}\nmu1 <- 20\nmu2 <- 40\nshape <- 10 # alpha\ny1 <- rgamma(1e5, shape = shape, scale = mu1/shape)\ny2 <- rgamma(1e5, shape = shape, scale = mu2/shape)\n\nc(mean(y1), mean(y2))\n#> [1] 19.98183 39.99907\nc(sd(y1), sd(y2)) # sd increase\n#> [1]  6.325026 12.702461\nc(cv(y1), cv(y2)) # cv is constant\n#> [1] 0.3165390 0.3175689\nc(psych::skew(y1), psych::skew(y2)) # skewness is similar\n#> [1] 0.6324545 0.6356682\n```\n:::\n\n\n\n\n## Example: the Simon effect\n\n> The Simon effect is the difference in accuracy or reaction time between trials in which stimulus and response are on the same side and trials in which they are on opposite sides, with responses being generally slower and less accurate when the stimulus and response are on opposite sides.\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Source: @van-den-Wildenberg2010-st](img/simon-task.jpg){fig-align='center'}\n:::\n:::\n\n\n\n## Example: the Simon effect\n\nLet's import the `data/simon.rda` file^[Source: https://github.com/michael-franke/aida-package]. You can use the `load()` function or the `read_rda()`.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsimon <- read_rda(here(\"data\", \"simon.rda\"))\nhead(simon)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 6 × 15\n#>   submission_id    RT condition   correctness class    experiment_id key_pressed\n#>           <dbl> <dbl> <chr>       <chr>       <chr>            <dbl> <chr>      \n#> 1          7432  1239 incongruent correct     Intro C…            52 q          \n#> 2          7432   938 incongruent correct     Intro C…            52 q          \n#> 3          7432   744 incongruent correct     Intro C…            52 q          \n#> 4          7432   528 incongruent correct     Intro C…            52 q          \n#> 5          7432   706 incongruent correct     Intro C…            52 p          \n#> 6          7432   547 congruent   correct     Intro C…            52 p          \n#> # ℹ 8 more variables: p <chr>, pause <dbl>, q <chr>, target_object <chr>,\n#> #   target_position <chr>, timeSpent <dbl>, trial_number <dbl>,\n#> #   trial_type <chr>\n```\n\n\n:::\n:::\n\n\n\n## Example: the Simon effect\n\nFor simplicity, let's consider only a single subject (`submission_id`: 7432), otherwise the model require including random effects. We also exclude strange trials with RT > 2500 ms.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"false\"}\nsimon <- filter(simon, \n                submission_id == 7432,\n                RT < 2500)\n```\n:::\n\n\n\n## Example: the Simon effect\n\nLet's plot the reaction times. Clearly the two distributions are right-skewed with a difference in location ($\\mu$). The shape also differs between thus also the skewness is probably different:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(simon, aes(x = RT, fill = condition)) +\n  geom_density(alpha = 0.7)\n```\n\n::: {.cell-output-display}\n![](04-gamma-glm_files/figure-revealjs/unnamed-chunk-26-1.svg){fig-align='center' width=576}\n:::\n:::\n\n\n\n## Example: the Simon effect\n\nLet's see some summary statistics. We see the difference between the two conditions.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"false\"}\nfuns <- list(mean = mean, sd = sd, skew = psych::skew, cv = cv)\nsumm <- tapply(simon$RT, simon$condition, function(x) sapply(funs, function(f) f(x)))\nsumm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> $congruent\n#>        mean          sd        skew          cv \n#> 504.1818182  81.7038670   0.5328521   0.1620524 \n#> \n#> $incongruent\n#>        mean          sd        skew          cv \n#> 564.0312500 123.4188852   2.8702013   0.2188157\n```\n\n\n:::\n:::\n\n\n\n## Example: the Simon effect\n\nGiven that we modelling the difference in $\\mu$, this is the expected difference. We are working on the log scale, thus the model is estimating the `log` difference or the `log` ratio.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"false\"}\nsumm$incongruent[\"mean\"] - summ$congruent[\"mean\"]\n#>     mean \n#> 59.84943\nlog(summ$incongruent[\"mean\"]) - log(summ$congruent[\"mean\"])\n#>      mean \n#> 0.1121727\nlog(summ$incongruent[\"mean\"] / summ$congruent[\"mean\"])\n#>      mean \n#> 0.1121727\n```\n:::\n\n\n\n## Example: the Simon effect\n\nLet's fit the model:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"false\"}\nfit <- glm(RT ~ condition, data = simon, family = Gamma(link = \"log\"))\nsummary(fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> \n#> Call:\n#> glm(formula = RT ~ condition, family = Gamma(link = \"log\"), data = simon)\n#> \n#> Coefficients:\n#>                      Estimate Std. Error t value Pr(>|t|)    \n#> (Intercept)           6.22294    0.02625 237.053  < 2e-16 ***\n#> conditionincongruent  0.11217    0.03580   3.134  0.00218 ** \n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#> \n#> (Dispersion parameter for Gamma family taken to be 0.03790215)\n#> \n#>     Null deviance: 4.1148  on 118  degrees of freedom\n#> Residual deviance: 3.7439  on 117  degrees of freedom\n#> AIC: 1424.4\n#> \n#> Number of Fisher Scoring iterations: 4\n```\n\n\n:::\n:::\n\n\n\n## Example: the Simon effect\n\nPlotting the results:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"false\"}\nplot(ggeffect(fit))\n```\n\n::: {.cell-output-display}\n![](04-gamma-glm_files/figure-revealjs/unnamed-chunk-30-1.svg){fig-align='center' width=576}\n:::\n:::\n\n\n\n## Example: the Simon effect\n\nThe main parameter of interest here is the $\\beta_1$ representing the difference in $\\mu$. We can interpret $\\exp(\\beta_1) = 1.119$ as the multiplicative increase in RT when moving from congruent to incongruent condition. In the RT scale, we have a difference of 59.8494318. Remember that the statistical test is performed on the link-function scale.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"false\"}\nemmeans(fit, pairwise ~ condition)$contrast\n#>  contrast                estimate     SE  df t.ratio p.value\n#>  congruent - incongruent   -0.112 0.0358 117  -3.134  0.0022\n#> \n#> Results are given on the log (not the response) scale.\nemmeans(fit, pairwise ~ condition, type = \"response\")$contrast\n#>  contrast                ratio    SE  df null t.ratio p.value\n#>  congruent / incongruent 0.894 0.032 117    1  -3.134  0.0022\n#> \n#> Tests are performed on the log scale\n```\n:::\n\n\n\n## More about the Gamma distribution\n\nI have written more notes about the intepretation of Gamma parameters especially for simulations:\n\n[https://filippogambarota.github.io/statnotes/understanding-gamma/understanding-gamma.html](https://filippogambarota.github.io/statnotes/understanding-gamma/understanding-gamma.html)\n\n## References\n\n::: {#refs}\n::: \n",
    "supporting": [
      "04-gamma-glm_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}